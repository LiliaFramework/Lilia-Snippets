{
	 
    "lia.anim.setModelClass(model, class)": {
        "prefix": "lia.anim.setModelClass",
        "body": "lia.anim.setModelClass(${1:model}, ${2:class})",
        "description": "[Lilia] A shared function to group a certain model with a specific animations. Class is a string that can be: 'citizen_male', 'citizen_female', 'metrocop', 'overwatch', 'vort', 'player', 'zombie' and 'fastZombie'. Note that the last three are only for regular player models, not NPC models."
    },
     
    "lia.anim.getModelClass(model)": {
        "prefix": "lia.anim.getModelClass",
        "body": "lia.anim.getModelClass(${1:model})",
        "description": "[Lilia] Returns the class for the model specified. If one has not been set previously, it will default to 'player' if the model contains '/player', otherwise the citizen classes."
    },
     
    "client:forceSequence(sequence, callback, time, noFreeze)": {
        "prefix": "forceSequence",
        "body": "forceSequence(${1:sequence}, ${2:callback}, ${3:time}, ${4:noFreeze})",
        "description": "[Lilia] Server-side function that overrides the player's current animation to play another animation. sequence is a string for the animation that can be viewed within the HL2 Model Viewer. callback is an optional function that gets called after the sequence is finished. time is an optional number to override how long the sequence plays for. noFreeze is an optional boolean to determine whether or not the player can move during the sequence."
    },
     
    "lia.attribs.setup(client)": {
        "prefix": "lia.attribs.setup",
        "body": "lia.attribs.setup(${1:client})",
        "description": "[Lilia] Loads all of the attribute effects for the player."
    },
     
    "client:updateAttrib(key, value)": {
        "prefix": "updateAttrib",
        "body": "updateAttrib(${1:key}, ${2:value})",
        "description": "[Lilia] Server-side function that increases a player's key attribute by value amount."
    },
     
    "client:setAttrib(key, value)": {
        "prefix": "setAttrib",
        "body": "setAttrib(${1:key}, ${2:value})",
        "description": "[Lilia] Server-side function that overwrites a player's key attribute to value."
    },
     
    "client:getAttrib(key, default)": {
        "prefix": "getAttrib",
        "body": "getAttrib(${1:key}, ${2:default})",
        "description": "[Lilia] Shared function that returns the key attribute or default if it is not set for the player."
    },
     
    "lia.bar.add(getValue, color, priority, identifier)": {
        "prefix": "lia.bar.add",
        "body": "lia.bar.add(${1:getValue}, ${2:color}, ${3:priority}, ${4:identifier})",
        "description": "[Lilia] Register new bar."
    },
     
    "lia.bar.draw(x, y, w, h, value, color)": {
        "prefix": "lia.bar.draw",
        "body": "lia.bar.draw(${1:x}, ${2:y}, ${3:w}, ${4:h}, ${5:value}, ${6:color})",
        "description": "[Lilia] Draw Bar on the screen."
    },
     
    "lia.bar.drawAction()": {
        "prefix": "lia.bar.drawAction",
        "body": "lia.bar.drawAction()",
        "description": "[Lilia] Draw Action Progress Bar."
    },
     
    "lia.bar.drawAll()": {
        "prefix": "lia.bar.drawAll",
        "body": "lia.bar.drawAll()",
        "description": "[Lilia] Draw All Library stuffs."
    },
     
    "client:Name()": {
        "prefix": "Name",
        "body": "Name()",
        "description": "[Lilia] Overwrites the old name function to return the character's name instead if applicable."
    },
     
    "lia.char.create(data, callback)": {
        "prefix": "lia.char.create",
        "body": "lia.char.create(${1:data}, ${2:callback})",
        "description": "[Lilia] A server-side function that inserts a character into the database from the CharacterCreateInfo data. The callback is called if provided which passes the new character's ID."
    },
     
    "lia.char.restore(client, callback, noCache, id)": {
        "prefix": "lia.char.restore",
        "body": "lia.char.restore(${1:client}, ${2:callback}, ${3:noCache}, ${4:id})",
        "description": "[Lilia] A server-side function that loads all Character objects owned by client from the database. If callback is provided, then the callback will be called with a table of characters passed. If noCache is provided, then the function will always load from the database. If the numeric id is passed, then the function will only load a character with the given ID."
    },
     
    "lia.char.new(data, id, client, steamID)": {
        "prefix": "lia.char.new",
        "body": "lia.char.new(${1:data}, ${2:id}, ${3:client}, ${4:steamID})",
        "description": "[Lilia] A shared function to create a new Character object with the given data table, which sets all of the character variables registered by lia.char.registerVar(). If the numeric ID is passed, then the character's ID property is set to the ID. The third argument, client, is the owner of the character. In the case that the owner is not valid, the fourth argument steamID can be used. Note that the steamID is the 64-bit SteamID, or the communityID."
    },
     
    "lia.char.hookVar(variable, name, callback)": {
        "prefix": "lia.char.hookVar",
        "body": "lia.char.hookVar(${1:variable}, ${2:name}, ${3:callback})",
        "description": "[Lilia] A shared function to provide a callback when the variable variable for a character is changed. name is the unique identifier for this hook. callback is called and has the character, old value and new value passed."
    },
     
    "lia.char.registerVar(variable, data)": {
        "prefix": "lia.char.registerVar",
        "body": "lia.char.registerVar(${1:variable}, ${2:data})",
        "description": "[Lilia] Creates a new character variable with data, a CharVar structure. The function extends the character by adding accessor functions, with the set* method being server-side and get* being shared.. For example, if variable was 'bar', then the function creates the character:setBar() and character:getBar() methods."
    },
     
    "lia.chat.register(string chatType, table data)": {
        "prefix": "lia.chat.register",
        "body": "lia.chat.register(${1:string chatType}, ${2:table data})",
        "description": "[Lilia] Purpose: Registers a new chat type using the ChatType structure."
    },
     
    "lia.chat.send(player speaker, string chatType, string text)": {
        "prefix": "lia.chat.send",
        "body": "lia.chat.send(${1:player speaker}, ${2:string chatType}, ${3:string text})",
        "description": "[Lilia] Purpose: Sends a chat message using the provided chatType."
    },
     
    "lia.command.list": {
        "prefix": "lia.command.list",
        "body": "lia.command.list",
        "description": "[Lilia] A list of all registered commands."
    },
     
    "lia.command.findPlayer(client, name)": {
        "prefix": "lia.command.findPlayer",
        "body": "lia.command.findPlayer(${1:client}, ${2:name})",
        "description": "[Lilia] A server-side function to find specific player with the provided name. If the player is not found, then the client will be notified."
    },
     
    "lia.command.run(client, command, arguments)": {
        "prefix": "lia.command.run",
        "body": "lia.command.run(${1:client}, ${2:command}, ${3:arguments})",
        "description": "[Lilia] A server-side function that runs a command as the given player. Arguments is a table that is directly passed to the command's onRun callback."
    },
     
    "lia.command.parse(client, text, realCommand, arguments)": {
        "prefix": "lia.command.parse",
        "body": "lia.command.parse(${1:client}, ${2:text}, ${3:realCommand}, ${4:arguments})",
        "description": "[Lilia] A server-side function to run a command given the player's raw chat text."
    },
     
    "lia.command.send(command, ...)": {
        "prefix": "lia.command.send",
        "body": "lia.command.send(${1:command}, ${2:...})",
        "description": "[Lilia] A client-side function to request a command to be ran to the server."
    },
     
    "lia.command.add(command, data)": {
        "prefix": "lia.command.add",
        "body": "lia.command.add(${1:command}, ${2:data})",
        "description": "[Lilia] A shared function that registers a chat commands."
    },
     
    "lia.command.extractArgs(text)": {
        "prefix": "lia.command.extractArgs",
        "body": "lia.command.extractArgs(${1:text})",
        "description": "[Lilia] A shared function to give a table of arguments from given text."
    },
     
    "lia.config.getChangedValues()": {
        "prefix": "lia.config.getChangedValues",
        "body": "lia.config.getChangedValues()",
        "description": "[Lilia] A server-side function to get all config values that is differs from the default value of the config values."
    },
     
    "lia.config.send(client)": {
        "prefix": "lia.config.send",
        "body": "lia.config.send(${1:client})",
        "description": "[Lilia] A server-side function that sends all changed config values to the client."
    },
     
    "lia.config.save()": {
        "prefix": "lia.config.save",
        "body": "lia.config.save()",
        "description": "[Lilia] A server-side function to save all configuration values."
    },
     
    "lia.config.add(key, value, desc, callback, data, noNetworking, schemaOnly)": {
        "prefix": "lia.config.add",
        "body": "lia.config.add(${1:key}, ${2:value}, ${3:desc}, ${4:callback}, ${5:data}, ${6:noNetworking}, ${7:schemaOnly})",
        "description": "[Lilia] Add config value to the server."
    },
     
    "lia.config.set(key, value)": {
        "prefix": "lia.config.set",
        "body": "lia.config.set(${1:key}, ${2:value})",
        "description": "[Lilia] Set/Change the config value."
    },
     
    "lia.config.get(key, default)": {
        "prefix": "lia.config.get",
        "body": "lia.config.get(${1:key}, ${2:default})",
        "description": "[Lilia] Get the config value."
    },
     
    "lia.config.load()": {
        "prefix": "lia.config.load",
        "body": "lia.config.load()",
        "description": "[Lilia] Load the config value."
    },
     
    "lia.currency.set(symbol, singular, plural)": {
        "prefix": "lia.currency.set",
        "body": "lia.currency.set(${1:symbol}, ${2:singular}, ${3:plural})",
        "description": "[Lilia] A shared function to define the symbol and name for the currency."
    },
     
    "lia.currency.get(amount)": {
        "prefix": "lia.currency.get",
        "body": "lia.currency.get(${1:amount})",
        "description": "[Lilia] Returns a nicely formatted name for amount money. For example, '$1 dollar' would be returned if amount was set to 1."
    },
     
    "lia.currency.spawn(position, amount[, angle])": {
        "prefix": "lia.currency.spawn",
        "body": "lia.currency.spawn(${1:position}, ${2:amount[}, ${3:angle]})",
        "description": "[Lilia] Spawns a money entity at position with amount money. The optional angle can be provided to set the angle of the money entity created. This function returns the money entity."
    },
     
    "character:hasMoney(amount)": {
        "prefix": "hasMoney",
        "body": "hasMoney(${1:amount})",
        "description": "[Lilia] Returns a boolean of whether or not the character's money is greater than or equal to amount."
    },
     
     
     
    "lia.data.set(key, value[, global, ignoreMap])": {
        "prefix": "lia.data.set",
        "body": "lia.data.set(${1:key}, ${2:value[}, ${3:global}, ${4:ignoreMap]})",
        "description": "[Lilia] Saves .txt file in gamemode server's data folder. The destination varies on the condition of parameters."
    },
     
    "lia.data.get(key[, default, global, ignoreMap, refresh])": {
        "prefix": "lia.data.get",
        "body": "lia.data.get(${1:key[}, ${2:default}, ${3:global}, ${4:ignoreMap}, ${5:refresh]})",
        "description": "[Lilia] Loads .txt file in gamemode server's data folder. The destination varies on the condition of parameters."
    },
     
    "lia.date.restore()": {
        "prefix": "lia.date.restore",
        "body": "lia.date.restore()",
        "description": "[Lilia] A server-side function to load the date from a previous session."
    },
     
    "lia.date.get()": {
        "prefix": "lia.date.get",
        "body": "lia.date.get()",
        "description": "[Lilia] Returns the in-game date as a time stamp."
    },
     
    "lia.date.send(client)": {
        "prefix": "lia.date.send",
        "body": "lia.date.send(${1:client})",
        "description": "[Lilia] Synchronizes a player's in-game date with the actual in-game date."
    },
     
    "lia.db.connect(callback)": {
        "prefix": "lia.db.connect",
        "body": "lia.db.connect(${1:callback})",
        "description": "[Lilia] For internal usage. You don't have to and must not call this function twice."
    },
     
    "lia.db.wipeTables()": {
        "prefix": "lia.db.wipeTables",
        "body": "lia.db.wipeTables()",
        "description": "[Lilia] RESETS THE DATABASE. Requires additional care for this function. Do not ever use RunString based console command to save your database."
    },
     
    "lia.db.loadTables()": {
        "prefix": "lia.db.loadTables",
        "body": "lia.db.loadTables()",
        "description": "[Lilia] For internal usage. Creates Default Tables."
    },
     
    "lia.db.convertDataType(value)": {
        "prefix": "lia.db.convertDataType",
        "body": "lia.db.convertDataType(${1:value})",
        "description": "[Lilia] Converts data to certain type which is more suitable to save in SQL Database."
    },
     
    "lia.db.insertTable(value, callback, dbTable)": {
        "prefix": "lia.db.insertTable",
        "body": "lia.db.insertTable(${1:value}, ${2:callback}, ${3:dbTable})",
        "description": "[Lilia] Inserts a row in the certain table with the callback. This is the function that you're going to use mostly."
    },
     
    "lia.db.updateTable(value, callback, dbTable, condition)": {
        "prefix": "lia.db.updateTable",
        "body": "lia.db.updateTable(${1:value}, ${2:callback}, ${3:dbTable}, ${4:condition})",
        "description": "[Lilia] Updates a row in the certain table with the callback. This is the function that you're going to use mostly."
    },
     
    "lia.db.query(DROP_QUERY, callback)": {
        "prefix": "lia.db.query",
        "body": "lia.db.query(${1:DROP_QUERY}, ${2:callback})",
        "description": "[Lilia] Runs Query on Database Server with the callback. This is the function that you're going to use mostly."
    },
     
    "lia.faction.teams": {
        "prefix": "lia.faction.teams",
        "body": "lia.faction.teams",
        "description": "[Lilia] Stores the list of the factions. This table's key is numeric and increment."
    },
     
    "lia.faction.indices": {
        "prefix": "lia.faction.indices",
        "body": "lia.faction.indices",
        "description": "[Lilia] Stores the list of the factions. This table's key value is not numeric. You can't use ipairs on this table."
    },
     
    "lia.faction.loadFromDir(directory)": {
        "prefix": "lia.faction.loadFromDir",
        "body": "lia.faction.loadFromDir(${1:directory})",
        "description": "[Lilia] An internal function to load all factions."
    },
     
    "lia.faction.hasWhitelist(faction)": {
        "prefix": "lia.faction.hasWhitelist",
        "body": "lia.faction.hasWhitelist(${1:faction})",
        "description": "[Lilia] A client-side function to determine if the local player has access to a certain faction."
    },
     
    "lia.flag.add(flag, desc[, callback])": {
        "prefix": "lia.flag.add",
        "body": "lia.flag.add(${1:flag}, ${2:desc[}, ${3:callback]})",
        "description": "[Lilia] A shared function to setup a flag. The flag itself should be one character. The callback is called server-side during the player's loadout or when the flag is taken/removed. The callback passes the affected player and a boolean of whether or not the flag is being given."
    },
     
    "lia.flag.onSpawn(client)": {
        "prefix": "lia.flag.onSpawn",
        "body": "lia.flag.onSpawn(${1:client})",
        "description": "[Lilia] A server-side function to run all the loadout callbacks for all of a player's flags."
    },
     
    "character:setFlags(flags)": {
        "prefix": "setFlags",
        "body": "setFlags(${1:flags})",
        "description": "[Lilia] Sets the stored flags for a character to the set string. This does not handle flag callbacks."
    },
     
    "character:giveFlags(flags)": {
        "prefix": "giveFlags",
        "body": "giveFlags(${1:flags})",
        "description": "[Lilia] Gives a character one or more flags. Each flag has its callback ran if applicable."
    },
     
    "character:takeFlags(flags)": {
        "prefix": "takeFlags",
        "body": "takeFlags(${1:flags})",
        "description": "[Lilia] Similar to giving flags, except the flag or flags are removed from the character's stored flags. The callback for each flag removed is ran."
    },
     
    "character:getFlags()": {
        "prefix": "getFlags",
        "body": "getFlags()",
        "description": "[Lilia] Returns all of the character's flags in one string."
    },
     
    "character:hasFlags(flags)": {
        "prefix": "hasFlags",
        "body": "hasFlags(${1:flags})",
        "description": "[Lilia] Returns a boolean of whether or not the character has at least one of the flags specified."
    },
     
    "lia.item.list": {
        "prefix": "lia.item.list",
        "body": "lia.item.list",
        "description": "[Lilia] Stores all Item Classes Objects in this table. You can get the item's information by calling lia.item.list[uniqueID]."
    },
     
    "lia.item.base": {
        "prefix": "lia.item.base",
        "body": "lia.item.base",
        "description": "[Lilia] Stores all Item Base Classes Objects in this table."
    },
     
    "lia.item.instances": {
        "prefix": "lia.item.instances",
        "body": "lia.item.instances",
        "description": "[Lilia] Stores all 'Loaded' Items Objects on the server. 'Loaded' means, Once item saved in the database and got wiped on instance table, you must initiate the item on the server before you use it for your own purpose. 'Item Index' is related with this table. You can get specific item's data with lia.item.instances[itemIndex]. Remember, If it does not exist, It needs to be loaded from the database or it just does not exist."
    },
     
    "lia.item.inventories": {
        "prefix": "lia.item.inventories",
        "body": "lia.item.inventories",
        "description": "[Lilia] Stores all 'Loaded' Inventory Objects on the server. Meaning of 'Loaded' is explained on the previous element, Item Instances."
    },
     
    "lia.item.instance()": {
        "prefix": "lia.item.instance",
        "body": "lia.item.instance()",
        "description": "[Lilia] Purpose: Creates new instance of Item Object on the server. This function does not returns any value. You need to put your post function calls on 'callback' parameter."
    },
     
    "lia.item.registerInv()": {
        "prefix": "lia.item.registerInv",
        "body": "lia.item.registerInv()",
        "description": "[Lilia] Purpose: Creates new type of inventory. Creating new inventory type allows you to sync inventory's size without sending extra information about the storage on the client."
    },
     
    "lia.item.newInv()": {
        "prefix": "lia.item.newInv",
        "body": "lia.item.newInv()",
        "description": "[Lilia] Purpose: Creates new instance of Inventory Object on the server. This function does not returns any value. You need to put your post function calls on 'callback' parameter."
    },
     
    "lia.item.load()": {
        "prefix": "lia.item.load",
        "body": "lia.item.load()",
        "description": "[Lilia] Purpose: Load and register item from lua file from the provided path. This function is for internal use."
    },
     
    "lia.item.register()": {
        "prefix": "lia.item.register",
        "body": "lia.item.register()",
        "description": "[Lilia] Purpose: Creates new Item Class on the server. You can create/generate new items with this function. But, For External use of this function, You need to provide 'true' on luaGenerated parameter."
    },
     
    "lia.item.new()": {
        "prefix": "lia.item.new",
        "body": "lia.item.new()",
        "description": "[Lilia] Purpose: Creates new Item Object. This function is for internal use."
    },
     
    "lia.item.createInv()": {
        "prefix": "lia.item.createInv",
        "body": "lia.item.createInv()",
        "description": "[Lilia] Purpose: Creates new Inventory Object. This fucntioin is for internal use."
    },
     
    "lia.item.restoreInv()": {
        "prefix": "lia.item.restoreInv",
        "body": "lia.item.restoreInv()",
        "description": "[Lilia] Purpose: Load Inventory Contents from the server. This function get called when invnetory is exist but it has no content. This function is for internal use."
    },
     
    "L(key, client[, ...])": {
        "prefix": "L",
        "body": "L(${1:key}, ${2:client[}, ${3:...]})",
        "description": "[Lilia] The server-side version of the translate function to get a localized version of a message for the player."
    },
     
    "L(key[, ...])": {
        "prefix": "L",
        "body": "L(${1:key[}, ${2:...]})",
        "description": "[Lilia] The client-side version of the translate function to get a localized message. The key corresponds to those found in language files. This function accepts a variable number of arguments. Each extra argument is used to substitute the '%s' found in the translations."
    },
     
    "lia.log.add(message[, flag])": {
        "prefix": "lia.log.add",
        "body": "lia.log.add(${1:message[}, ${2:flag]})",
        "description": "[Lilia] Adds a new line to the log for the current date. Flag corresponds to the flag enumerations and determines the color of the log in the console. If the flag is set to FLAG_SERVER, the log is not sent to administrators."
    },
     
    "lia.log.send(client, message, flag)": {
        "prefix": "lia.log.send",
        "body": "lia.log.send(${1:client}, ${2:message}, ${3:flag})",
        "description": "[Lilia] Shows a log to the specified recipient."
    },
     
    "lia.util.notify(message[, recipient])": {
        "prefix": "lia.util.notify",
        "body": "lia.util.notify(${1:message[}, ${2:recipient]})",
        "description": "[Lilia] On the server, this sends a notification to the specified recipient. The recipient can be nil to broadcast the notification. On the client, this function creates a new notification and the recipient is not used."
    },
     
    "lia.util.notifyLocalized(message[, recipient, ...])": {
        "prefix": "lia.util.notifyLocalized",
        "body": "lia.util.notifyLocalized(${1:message[}, ${2:recipient}, ${3:...]})",
        "description": "[Lilia] On the server, this sends a localized message to the recipient with the given parameters. Use this function to send translated messages if applicable as it does so more efficiently. On the client, this function does not have the recipient parameter."
    },
     
    "client:notify(message)": {
        "prefix": "notify",
        "body": "notify(${1:message})",
        "description": "[Lilia] Sends a notification to the client."
    },
     
    "client:notifyLocalized(message[, ...])": {
        "prefix": "notifyLocalized",
        "body": "notifyLocalized(${1:message[}, ${2:...]})",
        "description": "[Lilia] Sends a localized message to the client more efficiently."
    },
     
    "lia.util.include(fileName, state)": {
        "prefix": "lia.util.include",
        "body": "lia.util.include(${1:fileName}, ${2:state})",
        "description": "[Lilia] Includes the lua file."
    },
     
    "lia.util.includeDir(directory, fromLua)": {
        "prefix": "lia.util.includeDir",
        "body": "lia.util.includeDir(${1:directory}, ${2:fromLua})",
        "description": "[Lilia] Includes all lua files in the directory."
    },
     
    "lia.util.getAdmins(isSuper)": {
        "prefix": "lia.util.getAdmins",
        "body": "lia.util.getAdmins(${1:isSuper})",
        "description": "[Lilia] Returns table of the admins on the server."
    },
     
    "lia.util.getMaterial(materialPath)": {
        "prefix": "lia.util.getMaterial",
        "body": "lia.util.getMaterial(${1:materialPath})",
        "description": "[Lilia] Returns Pre-loaded Material."
    },
     
    "lia.util.findPlayer(name)": {
        "prefix": "lia.util.findPlayer",
        "body": "lia.util.findPlayer(${1:name})",
        "description": "[Lilia] Returns a player that includes provided string in thier name."
    },
     
    "lia.util.stringMatches(a, b)": {
        "prefix": "lia.util.stringMatches",
        "body": "lia.util.stringMatches(${1:a}, ${2:b})",
        "description": "[Lilia] Returns whether string is matches or not (not exactly, but partially.)"
    },
     
    "lia.util.emitQueuedSounds(entity, sounds, delay, spacing, volume, pitch)": {
        "prefix": "lia.util.emitQueuedSounds",
        "body": "lia.util.emitQueuedSounds(${1:entity}, ${2:sounds}, ${3:delay}, ${4:spacing}, ${5:volume}, ${6:pitch})",
        "description": "[Lilia] Emits Queued Sounds."
    },
     
    "lia.util.drawBlur(panel, amount, passes)": {
        "prefix": "lia.util.drawBlur",
        "body": "lia.util.drawBlur(${1:panel}, ${2:amount}, ${3:passes})",
        "description": "[Lilia] Draws blurs on the panel. Higher passes, Expensive Quality."
    },
     
    "lia.util.drawBlurAt(x, y, w, h, amount, passes)": {
        "prefix": "lia.util.drawBlurAt",
        "body": "lia.util.drawBlurAt(${1:x}, ${2:y}, ${3:w}, ${4:h}, ${5:amount}, ${6:passes})",
        "description": "[Lilia] Draws a blurred rectangle that big as w, h at position x and y with provided amount of passes."
    },
     
    "lia.util.drawText(text, x, y, color, alignX, alignY, font, alpha)": {
        "prefix": "lia.util.drawText",
        "body": "lia.util.drawText(${1:text}, ${2:x}, ${3:y}, ${4:color}, ${5:alignX}, ${6:alignY}, ${7:font}, ${8:alpha})",
        "description": "[Lilia] Draws a text on certain position with provided parameter."
    },
     
    "lia.util.findEmptySpace(entity, filter, spacing, size, height, tolerance)": {
        "prefix": "lia.util.findEmptySpace",
        "body": "lia.util.findEmptySpace(${1:entity}, ${2:filter}, ${3:spacing}, ${4:size}, ${5:height}, ${6:tolerance})",
        "description": "[Lilia] Find and Return Empty Space near around the entity."
    },
     
    "Entity:isDoor()": {
        "prefix": "isDoor",
        "body": "isDoor()",
        "description": "[Lilia] Returns whether the entity is door or not."
    },
     
    "Entity:getDoorPartner()": {
        "prefix": "getDoorPartner",
        "body": "getDoorPartner()",
        "description": "[Lilia] Returns the entity that tied together with provied entity object."
    },
     
    "Entity:blastDoor(velocity, lifeTime, ignorePartner)": {
        "prefix": "blastDoor",
        "body": "blastDoor(${1:velocity}, ${2:lifeTime}, ${3:ignorePartner})",
        "description": "[Lilia] Blasts door with veloctiy. The door will be restored after certain amount of the time. If ignorePartner is true, This function will blow all partner with the entity."
    },
     
    "Player:isWepRaised()": {
        "prefix": "isWepRaised",
        "body": "isWepRaised()",
        "description": "[Lilia] Returns the Weapon Raise status of the player."
    },
     
    "Player:isRunning()": {
        "prefix": "isRunning",
        "body": "isRunning()",
        "description": "[Lilia] Returns whether player is running or not (Whether player is moving above Default Waling Speed of the player.)"
    },
     
    "Player:isFemale()": {
        "prefix": "isFemale",
        "body": "isFemale()",
        "description": "[Lilia] Returns whether player is playing as female model or not. (This 'Female Model' means there is 'female' word on the model. (For defualt, this function checks 'female', 'alyx', 'mossman')"
    },
     
    "Player:getItemDropPos()": {
        "prefix": "getItemDropPos",
        "body": "getItemDropPos()",
        "description": "[Lilia] Returns the Good Item Dropping Position for the player."
    },
     
    "Player:isStuck()": {
        "prefix": "isStuck",
        "body": "isStuck()",
        "description": "[Lilia] Returns whether player is stuck or not."
    },
     
    "Player:setRagdolled(state, time, getUpGrace)": {
        "prefix": "setRagdolled",
        "body": "setRagdolled(${1:state}, ${2:time}, ${3:getUpGrace})",
        "description": "[Lilia] Set player ragdolled for certain amount of time if state is true."
    },
     
    "Player:setWepRaised(state)": {
        "prefix": "setWepRaised",
        "body": "setWepRaised(${1:state})",
        "description": "[Lilia] Set player's weapon raising state."
    },
     
    "Player:toggleWepRaised()": {
        "prefix": "toggleWepRaised",
        "body": "toggleWepRaised()",
        "description": "[Lilia] Toggles player's weapon rasing state."
    },
     
    "Player:setAction(text, time, callback, startTime, finishTime)": {
        "prefix": "setAction",
        "body": "setAction(${1:text}, ${2:time}, ${3:callback}, ${4:startTime}, ${5:finishTime})",
        "description": "[Lilia] Set Current Action of the player.This function will display a progress bar on the screen of the player. If the progress bar runs out, The callback function will run."
    },
    
	
     
    "vars": {
        "prefix": "vars",
        "body": "vars",
        "description": "[Lilia - Character] A table for all character variables set up by lia.char.registerVar"
    },
     
    "character:getID()": {
        "prefix": "getID",
        "body": "getID()",
        "description": "[Lilia - Character] Returns the id property."
    },
     
    "character:save([callback])": {
        "prefix": "save",
        "body": "save(${1:[callback]})",
        "description": "[Lilia - Character] Server-side method that saves all the character information to the database. This does nothing for a bot's character. Once the save is complete, a callback if provided will be called."
    },
     
    "character:sync([receiver])": {
        "prefix": "sync",
        "body": "sync(${1:[receiver]})",
        "description": "[Lilia - Character] Synchronizes the character's information to the receiver. If the receiver is nil, then everyone will receive the character's information. If a player is provided, only that player will receive the information. If the receiver is any other value, then only public variables are sent."
    },
     
    "character:setup(noNetworking)": {
        "prefix": "setup",
        "body": "setup(${1:noNetworking})",
        "description": "[Lilia - Character] The character's owner will have their model, character, and faction set. If noNetworking is true, then the character will not be synchronized for everyone."
    },
     
    "character:getPlayer()": {
        "prefix": "getPlayer",
        "body": "getPlayer()",
        "description": "[Lilia - Character] Returns the player who owns the character."
    },
     
    "character:setName(name)": {
        "prefix": "setName",
        "body": "setName(${1:name})",
        "description": "[Lilia - Character] Sets the name of the character to the provided string."
    },
     
    "character:setDesc(description)": {
        "prefix": "setDesc",
        "body": "setDesc(${1:description})",
        "description": "[Lilia - Character] Sets the character's description to the description provided."
    },
     
    "character:setModel(model)": {
        "prefix": "setModel",
        "body": "setModel(${1:model})",
        "description": "[Lilia - Character] Sets the character owner's model to the model provided."
    },
     
    "character:setClass(classID)": {
        "prefix": "setClass",
        "body": "setClass(${1:classID})",
        "description": "[Lilia - Character] Is similar to setting the team, but with a class."
    },
     
    "character:setFaction(factionID)": {
        "prefix": "setFaction",
        "body": "setFaction(${1:factionID})",
        "description": "[Lilia - Character] Changes the character owner's team to the faction provided."
    },
     
    "character:setAttribs(attributes)": {
        "prefix": "setAttribs",
        "body": "setAttribs(${1:attributes})",
        "description": "[Lilia - Character] Attributes is the table that controls all attribute values."
    },
     
    "character:setMoney(amount)": {
        "prefix": "setMoney",
        "body": "setMoney(${1:amount})",
        "description": "[Lilia - Character] Sets the character's money to the numeric amount provided."
    },
     
    "character:giveMoney(amount)": {
        "prefix": "giveMoney",
        "body": "giveMoney(${1:amount})",
        "description": "[Lilia - Character] Adds the numeric amount provided to the character's money."
    },
     
    "character:takeMoney(amount)": {
        "prefix": "takeMoney",
        "body": "takeMoney(${1:amount})",
        "description": "[Lilia - Character] Takes the absolute value of the numeric amount provided then subtracts that value from the character's current money."
    },
     
    "character:setData(key, value, isServerVar, recipientFilter)": {
        "prefix": "setData",
        "body": "setData(${1:key}, ${2:value}, ${3:isServerVar}, ${4:recipientFilter})",
        "description": "[Lilia - Character] Sets a networked variable for the character that is also stored in the database. **WARNING: ** This function is LOCAL. Which means the var will be networked only for the owner of character. To make this var networked public, you need to put 'player.getAll()' on recipentFilter."
    },
     
    "character:setVar(key, value, isServerVar, recipientFilter)": {
        "prefix": "setVar",
        "body": "setVar(${1:key}, ${2:value}, ${3:isServerVar}, ${4:recipientFilter})",
        "description": "[Lilia - Character] Similar to setting data, but the value is not saved to the database. **WARNING: ** This function is LOCAL. Which means the var will be networked only for the owner of character. To make this var networked public, you need to put 'player.getAll()' on recipentFilter."
    },
     
    "`character:getAttrib(key[, default])": {
        "prefix": "getAttrib",
        "body": "getAttrib(${1:key[}, ${2:default]})",
        "description": "[Lilia - Character] Returns a set attribute value or the default value if nil."
    },
     
    "character:updateAttrib(key, value)": {
        "prefix": "updateAttrib",
        "body": "updateAttrib(${1:key}, ${2:value})",
        "description": "[Lilia - Character] A server-side only function to add a value to the current attribute value."
    },
     
    "character:setAttrib(key, value)": {
        "prefix": "setAttrib",
        "body": "setAttrib(${1:key}, ${2:value})",
        "description": "[Lilia - Character] A server-side function to set an attribute to a certain value."
    },
     
    "character:getName()": {
        "prefix": "getName",
        "body": "getName()",
        "description": "[Lilia - Character] Returns the character's name as a string."
    },
     
    "character:getDesc()": {
        "prefix": "getDesc",
        "body": "getDesc()",
        "description": "[Lilia - Character] Returns the character's description as a string."
    },
     
    "character:getModel([default])": {
        "prefix": "getModel",
        "body": "getModel(${1:[default]})",
        "description": "[Lilia - Character] Returns the character's set model as a string or falls back on the default if provided."
    },
     
    "character:getClass([default])": {
        "prefix": "getClass",
        "body": "getClass(${1:[default]})",
        "description": "[Lilia - Character] Returns the character's set class as a number or falls back on the default if provided."
    },
     
    "character:getFaction()": {
        "prefix": "getFaction",
        "body": "getFaction()",
        "description": "[Lilia - Character] Returns the character's set faction as a number or falls back to 0 if nil."
    },
     
    "character:getAttribs([default])": {
        "prefix": "getAttribs",
        "body": "getAttribs(${1:[default]})",
        "description": "[Lilia - Character] Returns the character's attributes table or falls back on the default if provided."
    },
     
    "character:getMoney()": {
        "prefix": "getMoney",
        "body": "getMoney()",
        "description": "[Lilia - Character] Returns the character's money as a number."
    },
     
    "character:getData(key, [default])": {
        "prefix": "getData",
        "body": "getData(${1:key}, ${2:[default]})",
        "description": "[Lilia - Character] Returns a set data value from the key, but if the value is nil then the default will be returned if provided."
    },
     
    "character:getVar(key, [default])": {
        "prefix": "getVar",
        "body": "getVar(${1:key}, ${2:[default]})",
        "description": "[Lilia - Character] Returns a set variable from the key, but if the value is nil then the default will be returned if provided."
    },
     
    "character:getInv()": {
        "prefix": "getInv",
        "body": "getInv()",
        "description": "[Lilia - Character] Returns an Inventory object that the character owns."
    },
     
     
    "slots": {
        "prefix": "slots",
        "body": "slots",
        "description": "[Lilia - Inventory] This is the table for the inventory in the database. This table contains List of Item Objects that inventory contains."
    },
     
    "w h": {
        "prefix": "w h",
        "body": "w h",
        "description": "[Lilia - Inventory] This is the numeric value for the inventory in the database. This is the size of the inventory, which means the amount of items that the inventory object can hold."
    },
     
    "inventory:getSize()": {
        "prefix": "getSize",
        "body": "getSize()",
        "description": "[Lilia - Inventory] Returns the size of the inventory object."
    },
     
    "inventory:print(printPos?)": {
        "prefix": "print",
        "body": "print(${1:printPos?})",
        "description": "[Lilia - Inventory] Prints the simple information of the inventory object."
    },
     
    "inventory:findError()": {
        "prefix": "findError",
        "body": "findError()",
        "description": "[Lilia - Inventory] Find and Prints the error of the inventory object."
    },
     
    "inventory:printAll()": {
        "prefix": "printAll",
        "body": "printAll()",
        "description": "[Lilia - Inventory] Prints the all content of the inventory object."
    },
     
    "inventory:setOwner(client)": {
        "prefix": "setOwner",
        "body": "setOwner(${1:client})",
        "description": "[Lilia - Inventory] Sets the owner of the inventory object."
    },
     
    "inventory:canItemFit(x, y, w, h, item2)": {
        "prefix": "canItemFit",
        "body": "canItemFit(${1:x}, ${2:y}, ${3:w}, ${4:h}, ${5:item2})",
        "description": "[Lilia - Inventory] Returns whether the provided item size on the providied position can fit on current inventory or not."
    },
     
    "inventory:findEmptySlot(w, h, onlyMain)": {
        "prefix": "findEmptySlot",
        "body": "findEmptySlot(${1:w}, ${2:h}, ${3:onlyMain})",
        "description": "[Lilia - Inventory] Returns the x and y slot poistion for the provided size of the item."
    },
     
    "inventory:getItemAt(x, y)": {
        "prefix": "getItemAt",
        "body": "getItemAt(${1:x}, ${2:y})",
        "description": "[Lilia - Inventory] Returns the item object at the provided position."
    },
     
    "inventory:remove()": {
        "prefix": "remove",
        "body": "remove()",
        "description": "[Lilia - Inventory] Removes certain class of the item in the inventory."
    },
     
    "inventory:getReceiver()": {
        "prefix": "getReceiver",
        "body": "getReceiver()",
        "description": "[Lilia - Inventory] Get the networking recipicient filter of the inventory."
    },
     
    "inventory:getItemByID(itemClass)": {
        "prefix": "getItemByID",
        "body": "getItemByID(${1:itemClass})",
        "description": "[Lilia - Inventory] Searches the inventory slots with the provided item class and returns the found item object."
    },
     
    "inventory:getItems(onlyMain)": {
        "prefix": "getItems",
        "body": "getItems(${1:onlyMain})",
        "description": "[Lilia - Inventory] Gets all items in the inventory (If there is another inventory object in the inventory, includes their contents in the result if the recursive search is not supressed.)"
    },
     
    "inventory:getBags()": {
        "prefix": "getBags",
        "body": "getBags()",
        "description": "[Lilia - Inventory] Gets all other inventory objects in the current inventory object's slots."
    },
     
    "inventory:hasItem(itemClass, itemData)": {
        "prefix": "hasItem",
        "body": "hasItem(${1:itemClass}, ${2:itemData})",
        "description": "[Lilia - Inventory] Returns whether current inventory object has the item or not."
    },
     
    "inventory:sendSlot(x, y, item)": {
        "prefix": "sendSlot",
        "body": "sendSlot(${1:x}, ${2:y}, ${3:item})",
        "description": "[Lilia - Inventory] Sends an item to current/another inventory slot."
    },
     
    "inventory:add(itemClass, quantity, itemData, x, y, noReplication)": {
        "prefix": "add",
        "body": "add(${1:itemClass}, ${2:quantity}, ${3:itemData}, ${4:x}, ${5:y}, ${6:noReplication})",
        "description": "[Lilia - Inventory] Adds new/existing item on the current inventory object.1"
    },
     
    "inventory:sync()": {
        "prefix": "sync",
        "body": "sync()",
        "description": "[Lilia - Inventory] Synchronizes the inventory's information to the receiver. If the receiver is nil, then everyone will receive the inventory's information. If a player is provided, only that player will receive the information. If the receiver is any other value, then only public variables are sent."
    },
    
     
    "uniqueID": {
        "prefix": "uniqueID",
        "body": "uniqueID",
        "description": "[Lilia - Item] This is the string for the item in the database. This is referring the actual item data."
    },
     
    "data": {
        "prefix": "data",
        "body": "data",
        "description": "[Lilia - Item] This is the table for the item in the database. You can access/set variables on the specific item with ItemObject:getData(key), ItemObject:setData(key, value)."
    },
     
    "invID": {
        "prefix": "invID",
        "body": "invID",
        "description": "[Lilia - Item] This is the numeric value for the item in the database. This value displays where is item is parented. If the invID is 0 or nil, The item is on the ground or in the virtual space. The position value is gridX and gridY"
    },
     
    "item:getID()": {
        "prefix": "getID",
        "body": "getID()",
        "description": "[Lilia - Item] Returns the id property."
    },
     
    "item:getDesc()": {
        "prefix": "getDesc",
        "body": "getDesc()",
        "description": "[Lilia - Item] Returns the description of the item."
    },
     
    "item:print(isDetail)": {
        "prefix": "print",
        "body": "print(${1:isDetail})",
        "description": "[Lilia - Item] Prints simple data of object. (tostring only returns id)."
    },
     
    "item:printData()": {
        "prefix": "printData",
        "body": "printData()",
        "description": "[Lilia - Item] Prints all data of the item object."
    },
     
    "item:call(method, client, entity[, ...])": {
        "prefix": "call",
        "body": "call(${1:method}, ${2:client}, ${3:entity[}, ${4:...]})",
        "description": "[Lilia - Item] Calls the function of the item."
    },
     
    "item:hook(name, callback)": {
        "prefix": "hook",
        "body": "hook(${1:name}, ${2:callback})",
        "description": "[Lilia - Item] Hooks on to a call for an item function. This makes it easy to add on to item functions like dropping."
    },
     
    "item:getOwner()": {
        "prefix": "getOwner",
        "body": "getOwner()",
        "description": "[Lilia - Item] Returns the actual owner (a player) of the item."
    },
     
    "item:setData(key, value, receivers, noSave, checkEntity)": {
        "prefix": "setData",
        "body": "setData(${1:key}, ${2:value}, ${3:receivers}, ${4:noSave}, ${5:checkEntity})",
        "description": "[Lilia - Item] Sets persisting value to the item object. If checkEntity is true, When you set the data of the item, It will check the entity on the ground if the entity is valid(Which means, Check all dropped items.). If the entity is valid, it will sync the variable to all players."
    },
     
    "item:getData(key[, default])": {
        "prefix": "getData",
        "body": "getData(${1:key[}, ${2:default]})",
        "description": "[Lilia - Item] Gets persisting value of the item object."
    },
     
    "item:remove()": {
        "prefix": "remove",
        "body": "remove()",
        "description": "[Lilia - Item] Removes the item from existence and deletes the entity for the item if dropped."
    },
     
    "item:spawn(spawnPosition, spawnAngles)": {
        "prefix": "spawn",
        "body": "spawn(${1:spawnPosition}, ${2:spawnAngles})",
        "description": "[Lilia - Item] Spawn item on the world."
    },
     
    "item:getEntity()": {
        "prefix": "getEntity",
        "body": "getEntity()",
        "description": "[Lilia - Item] Gets the current entity that represents the item in the world."
    },
     
    "item:transfer(invID[, x, y, client, noReplication, isLogical])": {
        "prefix": "transfer",
        "body": "transfer(${1:invID[}, ${2:x}, ${3:y}, ${4:client}, ${5:noReplication}, ${6:isLogical]})",
        "description": "[Lilia - Item] Transfers the item to the other Inventory Object."
    }
}